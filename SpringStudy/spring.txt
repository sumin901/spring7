SpringFramework
SpringBoot

https://spring.io/
SpringFramework => Spring + Framework

 - Framework: 어떤 대상을 구성하는 구조/틀 사용한 작업
	=> (SW) 기능을 클래스/인터페이스 형태로 미리
	    구현해놓은 형태를 사용하는 것

 		EJB 			=> 			Spring Framework
  		서버중심					클라이언트중심(모바일등장)
    	  확장성,유지보수 			생산성,안정성	
    	  중량프레임워크			경량프레임워크
                        			(확장성-다른프레임워크의 포용)

 * 스프링 주요 개념/특징
  - EJB보다 가볍고,배우기쉽다.
  - 제어의 역행 기술을 사용해서 애플리케이션간의 느슨한 결합을 제어한다 .
    (Inversion Of Control,IoC)
  - 의존성 주입 기능을 사용가능.
    (Dependecy Injection, DI)
  - 관점지향 프로그래밍을 지원
    (Asepect-Oriented Programming, AOP)
  - 영속성 관련 다양한 서비스 지원
    (Presistence)
  - 다양한 라이브러리 지원
  - POJO기반의 구성
    (Plain Old Java Object)


  * 스프링 주요 기능
Spring Core : 다른 기능과 설정을 분리하기위한 IoC기능 제공
Spring Context : 스프링 기본기능, 애플리케이션에 있는 기능(빈-객체)을
                 접근하도록 기능을 제공    
Spring DAO :JDBC기능을 좀 더 편리하게 사용
Spring ORM :영속성관련 프레임워크 연동기능제공(하이버네이트,마이바티스)
Spring AOP : 관점지향 프로그래밍을 지원
Spring Web : 웹 개발에 필요한 기능을 제공
Spring WebMVC : 스프링MVC관련 기능 제공 


 - Spring Legacy Project
   was사용경험, Model2방식 개발
   아직까지 실무에서 사용빈도가 높음(이전코드)
   구글링이 쉬움(자료가 많다)
   모든 버전의 스프링을 사용가능
   
   초반설정 및 세팅이 어려움   
   
 - Spring Starter Project(Boot)
   초반설정 및 세팅이 쉬움(기본제공)
   내장서버를 보유하고 있음 => 로딩시간이 짧음
   별도의 버젼을 설정하지 않아도됨(라이브러리별 호환성 높음)
   
   기존의 방식과 다른 형태로 개발,JSP 뷰사용 다소어려움
 
	*	Presentation Layer 	: UI 구성부분 (웹,모바일)
							=> html, css, js, jsp, Controller 
	
	*	Business Layer 		: 서비스 계층, 요구사항을 구현하는 부분
							=> ****Action... 
	
	*	Data Access Layer	: 영속 계층, 데이터 처리 수행
							=> ***DAO...
	
	*	DataBase

======================================================================================================================				
	
	요청 	->	Controller	->	(Model->Service)	-> DAO	-> MyBatis	-> DB 	
	(request)
				View
				
======================================================================================================================				
				
	< MyBatis !>
	마이바티스는 무엇인가?
	
	마이바티스는 개발자가 지정한 SQL, 저장프로시저 그리고 몇가지 고급 매핑을 지원하는 퍼시스턴스 프레임워크이다. 
	마이바티스는 JDBC로 처리하는 상당부분의 코드와 파라미터 설정및 결과 매핑을 대신해준다.
	마이바티스는 데이터베이스 레코드에 원시타입과 Map 인터페이스 그리고 자바 POJO 를 설정해서 매핑하기 위해
	XML과 애노테이션을 사용할 수 있다.
	
	! 기존 JDBC의 단점(귀찮음)을 보완하는 프레임워크
		- try-catch-finally 생략
		- pstmt, rs 데이터 입력 생략
		- SQL 구문을 분리할 수 있다
		- Spring과의 연결이 자동
		- 동적 SQL 지원
		
======================================================================================================================

	<bean id="dataSource"
			class="org.springframework.jdbc.datasource.DriverManagerDataSource"> 
			<property name="driverClassName" value="com.mysql.cj.jdbc.Driver"/>
	</bean>
	
	bean 태그 : new 키워드를 대신해 객체를 생성한다.
	
	DriverManagerDataSource dataSource = new DriverManagerDataSource()
	|| 같다 
	<bean id="dataSource"
		class "org.springframework.jdbc.datasource.DriverManagerDataSource"> 
	</bean>
	
	dataSource.setDriverClassName("com.mysql.cj.jdbc.Driver");
	||
	<property name="driverClassName" value="com.mysql.cj.jdbc.Driver"/>
	
======================================================================================================================	
	
	<의존 객체 자동 주입> => 개발자가 주입대상을 명시하지 않아도 자동으로 연결(스프링, 스프링컨테이너가)
	
	키워드 : @Inject, @Autowired, @Resource
	
	@Resource : 자바에서 지원하는 어노테이션 (특정 프레임워크에 비종속적이다)
				! 의존 객체를 찾는 순서 : 1. [이름] -> 2. [타입] -> 3. [@Qualifier] -> 실패
				! 멤버변수, set메서드에서만 선언 가능하다
				
	@Inject : 	자바에서 지원하는 어노테이션 (특정 프레임워크에 비종속적이다)
				! 의존 객체를 찾는 순서 : 1. [타입] -> 2. [@Qualifier] -> 3. [이름] -> 실패
				! 빌드 도구(Maven)를 사용해 해당 라이브러리 의존성 추가 필수 
				! 멤버변수, set메서드, 생성자, 일반메서드 선언 가능
	
	@Autowired : Spring에서 지원하는 어노테이션(Spring에 종속적)
				! 의존 객체를 찾는 순서 : 1. [타입] -> 2. [이름] -> 3. [@Qualifier] -> 실패
				- 반드시 스프링에서만 사용
				- 멤버변수, set메서드, 생성자, 일반메서드 선언 가능
	
	
	@Qualifier ? 
	주입하려는 대상이 여러 개 있을 때 해당 대상을 구분하기위한 값
		! Qualifier로 설정한 객체가 없을 경우 Exception 오류가 발생
	
	예) 
	<bean id="dataSource"
		class="org.springframework.jdbc.datasource.DriverManagerDataSource">
		<qualifier value="ds1" />
		... 
	</bean>
	
	<bean id="dataSource"
		class="org.springframework.jdbc.datasource.DriverManagerDataSource">
		<qualifier value="ds2" />
		... 
	</bean>
	
	----------------------------------------------------------------
	Qualifier 사용 시 
	@Autowired @Qualifier("ds2")
	private DataSource ds;
	
==========================================================================================================================
	
	* DAO	-> MyBatis	-> DB + Test(JUnit)
		
	1) XML을 사용해 SQL작성, DAO 객체 생성해 연결
		- 장점 : 쿼리를 분리하기 때문에 SQL 구문 수정 및 유지보수가 우수하다(별도의 컴파일을 하지 않음)
		- 단점 : 개발 시 코드의 양이 증가 = 코드의 복잡도 증가
		
	2) 어노테이션을 사용해 SQL 작성하고, DAO 인터페이스를 생성해 연결
		- 장점 : 별도의 DAO 객체없이, DAO 인터페이스만으로도 처리 가능함 = 생산성 증가, 효율성 증가
		- 단점 : 쿼리 변경 시 매번 컴파일을 진행해야함
		
	3) XML/어노테이션 사용해 SQL 작성하고, DAO 객체 생성해서 연결
		- 장점 : 1,2의 단점을 보완 = 간단한 쿼리 : 어노테이션, 복잡한 쿼리 : XML 사용해 처리
		- 단점 : 개발자의 역량에 따라 효율성에 큰 편차가 존재
	
	----------------------------------------------------------------------------------------------------
	
	* MyBatis 개발 사용 순서
	
	1. 데이터베이스 생성 (+계정 생성)
	
	2. 테이블 생성, 설정 준비
	
	3. 도메인 객체(클래스) 생성 = DTO 생성 = VO 생성
		!도메인 : 해당 프로젝트에 중요한 용어(단어) // 물리적인 환경으로 분리가능한 단위로 나눈다
			ex) 쇼핑몰 : 회원, 상품, 관리자, 주문, 장바구니 ...	(1차 도메인)
						 이름, 상품번호, ...					(2차 도메인)
	
	4. DAO 인터페이스 생성
	
	5. 인터페이스에 구현할 동작을 추상메서드로 선언
	
	6. XML(Mapper) 생성, 위치(저장경로=namespace) 설정
	
	7. XML mapperDTD 추가
	
	8. SQL 구문 작성(태그형태)
	
	9. XML(mapper) 정보를 MyBatis에서 인식하도록 설정
	
	10. DAO 객체 생성
	
	11. 테스트
	
==============================================================================================================

	* log4j : 로그 출력 기능( 로그 레벨별 출력 기능 )
	
							심각도 증가
	-------------------------------------------------------------->
	1			2			3			4			5			6
	TRACE		DEBUG		INFO		WARNING		ERROR		FATAL	
	
	1. TRACE 	: DEBUG보다 상세한 로그 정보 출력
	2. DEBUG 	: 개발 시 디버깅용
	3. INFO 	: 실제 서비스 운영과 관련된 정보 출력
	4. WARNING	: 시스템(서버) 오류의 원인 출력
	5. ERROR	: 시스템(서버) 실행 중 문제 정보 출력
	6. FATAL 	: 시스템(서버 환경) 자체의 문제 정보 출력
	
	! 출력 설정한 레벨보다 높은 레벨의 메시지만 출력됨
	
	
	https://logging.apache.org/log4j/2.x/manual/index.html
	
==============================================================================================================
	
	Mapper 설정
	
	<insert id="insertMember">
		insert into tbl_member (userid, userpw, username, useremail) 
		values (#{userid},#{userpw},#{username},#{useremail})
	</insert>	
	
	#{userid} => MyBatis가 pstmt.setString("userid") 를 대신 수행한다
	
==============================================================================================================

	메서드 작성 시 전달 값(파라미터)에 각각의 정보를 개별로 전달하는 것보다
	VO 객체로 한번에 넘기는 방식이 유지보수적인 측면에서 효율적임. 생산성 UP
	
====================================================================================================================================================================================
	
	
	public MemberVO loginMember(String userid, String userpw) {

	logger.debug("loginMember(String userid, String userpw) 실행");
	MemberVO mvo = new MemberVO();
	mvo.setUserid(userid);
	mvo.setUserpw(userpw);
	MemberVO resultVO = sqlSession.selectOne(NAMESPACE+"loginMember", mvo);
	
	
	return resultVO;
	
	}
	
	위 메서드에서 파라미터 값으로 개별의 값을 받아 객체에 담아 저장한 뒤 객체를 mapper에게 전달해주는데
	예를 들어 찜하기 기능을 구현한다고 치면 
	유저아이디, 상품 번호 등이 필요한데
	유저랑 상품 VO는 구분되어 member, product로 구현했을텐데
	도메인이라는 개념을 도입하므로써 두 개의 정보를 하나의 객체에 저장할 수는 없다
	그렇기 때문에 mapper에게 객체를 전달할 때 새로운 객체를 만드는 방식으로 map을 사용해서 map<k,v> 의 방식으로 전달해줌
	
------------------수정한 메서드-------------------------------------------------------------------------------------------------	
	
	public MemberVO loginMember(String userid, String userpw) {

		logger.debug("loginMember(String userid, String userpw) 실행");
//		MemberVO mvo = new MemberVO();
//		mvo.setUserid(userid);
//		mvo.setUserpw(userpw);
		Map<String, Object> paramMap = new HashMap<String, Object>();
		paramMap.put("userid", userid);
		paramMap.put("userpw", userpw);
		
		MemberVO resultVO = sqlSession.selectOne(NAMESPACE+"loginMember", paramMap);
		
		
		return resultVO;
	}
	
------------------수정한 메서드-------------------------------------------------------------------------------------------------	
	
============================================================================================================================================
	
	요청 	->	Controller	->	(Model->Service)	-> DAO	-> MyBatis	-> DB 	
	(request)	 |
				View
	
	* Controller
	
	[ 스프링 MVC에서 기본적으로 처리하는 작업 ]
	 - URI를 분석해 적절한 컨트롤러를 찾는 작업 (*.me, *.bo ...)
	 - 컨트롤러에 필요한 메서드 호출
	 - 컨트롤러의 데이터(결과)를 뷰페이지로 전달( 기존 : request영역저장 + forwarding )
	 - URI에 따른 뷰페이지 연결 (기존 : Actionforward.setPath() )
	 - 파라미터 자동 수집 (VO에 대한 수집 + ...)
	 - 테스트 / 개발로직에 집중할 수 있다
	 
	[ 개발자가 수행하는 작업 ]
	 - 특정 URI에 동작하는 컨트롤러 설계(맵핑)
	 - 서비스 객체 생성
	 - DAO 객체 생성
	 - 컨트롤러 내부에 동작을 처리하는 메서드 설계
	 - 전달받은 데이터를 뷰 페이지에 출력
	 
============================================================================================================================================
	
	@Controller
	public class SampleController2 {
	
	private static final Logger logger = LoggerFactory.getLogger(SampleController2.class);
	
	//http://localhost:8088/web/doB?msg="ITWILL&age=20"
	@GetMapping(value = "/doB")
	public String doB (@ModelAttribute("msg") String msg, 
					   @ModelAttribute("age") int age) {
		// 기본형 타입 리턴 불가 !
		// String 타입만 리턴 할 수 있음
		logger.debug("doB() 실행");
		logger.debug("msg : " + msg);
		logger.debug("age : " + age);
		
		
		// 메서드 리턴타입 : String -> "리턴".jsp 뷰 페이지 연결
		return "itwill";
		
	}
	
}

	@ModelAttribute("전달받는 파라미터 이름") 저장타입 저장변수명
	@ModelAttribute("age") 						int       age
	
============================================================================================================================================

	private static final Logger logger = LoggerFactory.getLogger(SampleController4.class);
	
	@RequestMapping(value="/doD" ,method = RequestMethod.GET)
	public String doD() {
		logger.debug("doD() 실행");
		return "/doE";
	}
	
	@RequestMapping(value="/doE" ,method = RequestMethod.GET)
	public void doE() {
		logger.debug("doE() 실행");
		
	}
	
	return 의 의미 : 연결되는 뷰 페이지의 이름 설정
	// doD 주소창 실행 시 doE.jsp 연결 != doE() 메서드 실행
	// 
	
------------------------------------------------------------------------------------------------------------------------------------------------------------------------

	return "redirect:/doE";
	return "forward:/doE";
	
------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	

============================================================================================================================================

	@RequestParam : 주소줄에 있는 이름(Key)을 가진 데이터 값을 가져온다  
	1:1 관계
	
	Model : View 페이지로 데이터(정보) 전달하는 객체, 데이터의 이름과 값(value, Bean, Collection)을 저장할 수 있다
	1:N의 관계 
	
	@ModelAttribute : 주소줄에 있는 이름(Key)을 가진 데이터 값(value, Bean, Collection)을 저장할 수 있다
	1:N의 관계 		=> Model 객체에 담아 정보를 View 페이지로 전달
		
** Model.addAttribute() 			VS				@ModelAttribute	
	메서드 단위										컨트롤러 단위
	key,value, Model 저장 							전달된 정보(key,value) -> 객체 -> Model 객체 
	-> 뷰페이지 전달								-> 뷰페이지 전달
	
	@RedirectAttributes
		addAttribute() 		: URI 표기 O - Model, RedirectAttributes 사용가능	- F5시 데이터 유지O 	
		addFlashAttribute()	: URI 표기 X - RedirectAttributes만 사용가능		- F5시 데이터 유지X

============================================================================================================================================
============================================================================================================================================
============================================================================================================================================
============================================================================================================================================
============================================================================================================================================
============================================================================================================================================
============================================================================================================================================
============================================================================================================================================
============================================================================================================================================
============================================================================================================================================
============================================================================================================================================
============================================================================================================================================
============================================================================================================================================
	
	
	
	